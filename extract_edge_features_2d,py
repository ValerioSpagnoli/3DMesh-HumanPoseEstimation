import os
import trimesh
import torch
from tqdm import tqdm

def batch_simple_features_2d(edges_properties, device):
    """
    Process all edge properties in a batch instead of iterating over each edge.
    """
    num_edges = len(edges_properties)

    # Pre-allocate tensors for all edges and their neighbors
    edge_vertices_0 = torch.zeros((num_edges, 3), device=device)
    edge_vertices_1 = torch.zeros((num_edges, 3), device=device)
    neighbor_0_v0 = torch.zeros((num_edges, 3), device=device)
    neighbor_0_v1 = torch.zeros((num_edges, 3), device=device)
    neighbor_1_v0 = torch.zeros((num_edges, 3), device=device)
    neighbor_1_v1 = torch.zeros((num_edges, 3), device=device)
    
    # Fill tensors with edge and neighbor vertices
    for i, edge_properties in enumerate(edges_properties):
        edge_vertices_0[i] = torch.tensor(edge_properties['vertices'][0], device=device)
        edge_vertices_1[i] = torch.tensor(edge_properties['vertices'][1], device=device)

        neighbor_0_v0[i] = torch.tensor(edge_properties['face_0']['neighbor_0']['vertices'][0], device=device)
        neighbor_0_v1[i] = torch.tensor(edge_properties['face_0']['neighbor_0']['vertices'][1], device=device)

        neighbor_1_v0[i] = torch.tensor(edge_properties['face_0']['neighbor_1']['vertices'][0], device=device)
        neighbor_1_v1[i] = torch.tensor(edge_properties['face_0']['neighbor_1']['vertices'][1], device=device)

    # Compute edge lengths in batch
    edge_lengths = torch.norm(edge_vertices_0 - edge_vertices_1, dim=1, keepdim=True)
    neighbor_0_lengths = torch.norm(neighbor_0_v0 - neighbor_0_v1, dim=1, keepdim=True)
    neighbor_1_lengths = torch.norm(neighbor_1_v0 - neighbor_1_v1, dim=1, keepdim=True)

    # Concatenate the features in a batch
    edge_features = torch.cat([edge_vertices_0, edge_vertices_1, edge_lengths], dim=1)
    neighbor_0_features = torch.cat([neighbor_0_v0, neighbor_0_v1, neighbor_0_lengths], dim=1)
    neighbor_1_features = torch.cat([neighbor_1_v0, neighbor_1_v1, neighbor_1_lengths], dim=1)

    # Stack all features into a single tensor [num_edges, 3 (features), 7 (dimensions)]
    return torch.stack([edge_features, neighbor_0_features, neighbor_1_features], dim=1)

def compute_edges_properties(mesh):
    vertices = mesh.vertices
    faces = mesh.faces

    edge_to_faces = {}
    for face in faces:
        face_edges = [tuple(sorted((face[i], face[(i + 1) % 3]))) for i in range(3)]
        for edge in face_edges:
            edge_to_faces.setdefault(edge, []).append(face)

    edges_properties = []
    for edge, faces_containing_edge in edge_to_faces.items():
        edge_properties = {
            'edge': edge,
            'vertices': [vertices[edge[0]], vertices[edge[1]]],
            'face_0': {'vertices': [], 'neighbor_0': {'vertices': []}, 'neighbor_1': {'vertices': []}},
            'face_1': {'vertices': [], 'neighbor_0': {'vertices': []}, 'neighbor_1': {'vertices': []}}
        }

        for i, face in enumerate(faces_containing_edge):
            neighbors_edges = [tuple(sorted((face[j], face[(j + 1) % 3]))) for j in range(3) if tuple(sorted((face[j], face[(j + 1) % 3]))) != edge]
            edge_properties[f'face_{i}']['vertices'] = [vertices[face[0]], vertices[face[1]], vertices[face[2]]]
            edge_properties[f'face_{i}']['neighbor_0']['vertices'] = [vertices[neighbors_edges[0][0]], vertices[neighbors_edges[0][1]]]
            edge_properties[f'face_{i}']['neighbor_1']['vertices'] = [vertices[neighbors_edges[1][0]], vertices[neighbors_edges[1][1]]]

        edges_properties.append(edge_properties)
    
    return edges_properties

if __name__ == '__main__':
    dataset_path = 'datasets/human/'
    processed_data_path = 'datasets/simple_edge_features_2d/'
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    for subfolder in os.listdir(dataset_path):
        subfolder_path = os.path.join(dataset_path, subfolder)
        if os.path.isdir(subfolder_path):
            print(f"Processing subfolder {subfolder} ...")
            mesh_files = [f for f in os.listdir(subfolder_path) if f.endswith('.obj')]

            for mesh_file in tqdm(mesh_files, desc=f'Processing meshes in {subfolder}'):
                mesh_path = os.path.join(subfolder_path, mesh_file)
                mesh = trimesh.load(mesh_path)
                edges_properties = compute_edges_properties(mesh)

                # Use batch processing for edge features
                edges_features = batch_simple_features_2d(edges_properties, device)
                
                subfolder_processed_path = os.path.join(processed_data_path, subfolder)
                os.makedirs(subfolder_processed_path, exist_ok=True)

                processed_data_file = os.path.join(subfolder_processed_path, f"edges_features_{mesh_file.split('.')[0]}.pt")
                torch.save(edges_features, processed_data_file)
